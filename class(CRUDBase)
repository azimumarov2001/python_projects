from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Table
from sqlalchemy.orm import declarative_base, Session, sessionmaker, relationship
from pydantic import BaseModel
from typing import List, Optional, Generic, TypeVar, Type

DATABASE_URL = "sqlite:///database.db"
engine = create_engine(DATABASE_URL, connect_args={'check_same_thread': False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
app = FastAPI()
student_course = Table(
    "student_course",
    Base.metadata,
    Column("student_id", Integer, ForeignKey("students.id"), primary_key=True),
    Column("course_id", Integer, ForeignKey("courses.id"), primary_key=True)
)

teacher_course = Table(
    "teacher_course",
    Base.metadata,
    Column("teacher_id", Integer, ForeignKey("teachers.id"), primary_key=True),
    Column("course_id", Integer, ForeignKey("courses.id"), primary_key=True)
)


class Student(Base):
    __tablename__ = "students"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)

    # Связь many-to-many с курсами
    courses = relationship("Course", secondary=student_course, back_populates="students")


class Course(Base):
    __tablename__ = "courses"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)


    students = relationship("Student", secondary=student_course, back_populates="courses")
    teachers = relationship("Teacher", secondary=teacher_course, back_populates="courses")


class Teacher(Base):
    __tablename__ = "teachers"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)

    courses = relationship("Course", secondary=teacher_course, back_populates="teachers")


class CreateStudent(BaseModel):
    name: str


class CreateCourse(BaseModel):
    title: str


class CreateTeacher(BaseModel):
    name: str


class StudentSimpleOut(BaseModel):
    id: int
    name: str

    class Config:
        orm_mode = True


class CourseSimpleOut(BaseModel):
    id: int
    title: str

    class Config:
        orm_mode = True


class TeacherSimpleOut(BaseModel):
    id: int
    name: str

    class Config:
        orm_mode = True


class TeacherOut(BaseModel):
    id: int
    name: str
    courses: List[CourseSimpleOut] = []

    class Config:
        orm_mode = True


class CourseOut(BaseModel):
    id: int
    title: str
    students: List[StudentSimpleOut] = []
    teachers: List[TeacherSimpleOut] = []

    class Config:
        orm_mode = True


class StudentOut(BaseModel):
    id: int
    name: str
    courses: List[CourseSimpleOut] = []

    class Config:
        orm_mode = True


class UpdateStudent(BaseModel):
    name: Optional[str] = None

    class Config:
        orm_mode = True


class UpdateCourse(BaseModel):
    title: Optional[str] = None

    class Config:
        orm_mode = True


class UpdateTeacher(BaseModel):
    name: Optional[str] = None

    class Config:
        orm_mode = True


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
SimpleOutSchemaType = TypeVar("SimpleOutSchemaType", bound=BaseModel)
OutSchemaType = TypeVar("OutSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)


class CRUDBase(Generic[ModelType, CreateSchemaType, SimpleOutSchemaType, OutSchemaType, UpdateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model

    def get_all(self, db: Session) -> List[ModelType]:
        return db.query(self.model).all()

    def get(self, obj_id: int, db: Session) -> ModelType:
        return db.query(self.model).filter(self.model.id == obj_id).first()

    def create(self, obj: CreateSchemaType, db: Session) -> ModelType:
        obj_data = self.model(**obj.dict(exclude_unset=True))
        db.add(obj_data)
        db.commit()
        db.refresh(obj_data)
        return obj_data

    def update(self, db_obj: ModelType, obj_type: UpdateSchemaType, db: Session) -> ModelType:
        obj_data = obj_type.dict(exclude_unset=True)
        for field, value in obj_data.items():
            setattr(db_obj, field, value)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def remove(self, obj_id: int, db: Session):
        obj = db.query(self.model).filter(self.model.id == obj_id).first()
        if obj:
            db.delete(obj)
            db.commit()
            return obj


student_crud = CRUDBase[Student, CreateStudent, StudentSimpleOut, StudentOut, UpdateStudent](Student)
course_crud = CRUDBase[Course, CreateCourse, CourseSimpleOut, CourseOut, UpdateCourse](Course)
teacher_crud = CRUDBase[Teacher, CreateTeacher, TeacherSimpleOut, TeacherOut, UpdateTeacher](Teacher)

Base.metadata.create_all(bind=engine)


@app.get("/students", response_model=List[StudentSimpleOut])
def read_students(db: Session = Depends(get_db)):
    return db.query(Student).all()


@app.get("/students/{student_id}", response_model=StudentSimpleOut)
def read_student(student_id: int, db: Session = Depends(get_db)):
    get_student = student_crud.get(student_id, db)
    if not get_student:
        raise HTTPException(status_code=404, detail="Student not found")
    return get_student


@app.post("/students", response_model=StudentSimpleOut)
def create_student(student: CreateStudent, db: Session = Depends(get_db)):
    if db.query(Student).filter(Student.name == student.name).first():
        raise HTTPException(status_code=400, detail="Student already exists")
    return student_crud.create(student, db)


@app.put("/students/{student_id}", response_model=StudentSimpleOut)
def update_student(student_id: int, student_update: UpdateStudent, db: Session = Depends(get_db)):
    put_student = student_crud.get(student_id, db)
    if not put_student:
        raise HTTPException(status_code=404, detail="Student not found")
    return student_crud.update(put_student, student_update, db)


@app.delete("/students/{student_id}")
def delete_students(student_id: int, db: Session = Depends(get_db)):
    delete_student = student_crud.remove(student_id, db)
    if not delete_student:
        raise HTTPException(status_code=404, detail="Student not found")
    return delete_student


@app.get("/courses", response_model=List[CourseSimpleOut])
def read_courses(db: Session = Depends(get_db)):
    return db.query(Course).all()


@app.get("/courses/{course_id}", response_model=CourseSimpleOut)
def read_course(course_id: int, db: Session = Depends(get_db)):
    get_course = course_crud.get(course_id, db)
    if not get_course:
        raise HTTPException(status_code=404, detail="Course not found")
    return get_course


@app.post("/courses", response_model=CourseSimpleOut)
def create_course(course: CreateCourse, db: Session = Depends(get_db)):
    if db.query(Course).filter(Course.title == course.title).first():
        raise HTTPException(status_code=400, detail="Course already exists")
    return course_crud.create(course, db)


@app.put("/courses/{course_id}", response_model=CourseSimpleOut)
def update_course(course_id: int, course_update: UpdateCourse, db: Session = Depends(get_db)):
    put_course = course_crud.get(course_id, db)
    if not put_course:
        raise HTTPException(status_code=404, detail="Course not found")
    return course_crud.update(put_course, course_update, db)


@app.delete("/courses/{course_id}")
def delete_courses(course_id: int, db: Session = Depends(get_db)):
    delete_course = course_crud.remove(course_id, db)
    if not delete_course:
        raise HTTPException(status_code=404, detail="Course not found")
    return delete_course


@app.get("/teachers", response_model=List[TeacherSimpleOut])
def read_teachers(db: Session = Depends(get_db)):
    return db.query(Teacher).all()


@app.get("/teachers/{teacher_id}", response_model=TeacherSimpleOut)
def read_teacher(teacher_id: int, db: Session = Depends(get_db)):
    get_teacher = teacher_crud.get(teacher_id, db)
    if not get_teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")
    return get_teacher


@app.post("/teachers", response_model=TeacherSimpleOut)
def create_teacher(teacher: CreateTeacher, db: Session = Depends(get_db)):
    if db.query(Teacher).filter(Teacher.name == teacher.name).first():
        raise HTTPException(status_code=400, detail="Teacher already exists")
    return teacher_crud.create(teacher, db)


@app.put("/teachers/{teacher_id}", response_model=TeacherSimpleOut)
def update_teacher(teacher_id: int, teacher_update: UpdateTeacher, db: Session = Depends(get_db)):
    put_teacher = teacher_crud.get(teacher_id, db)
    if not put_teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")
    return teacher_crud.update(put_teacher, teacher_update, db)


@app.delete("/teachers/{teacher_id}")
def delete_teachers(teacher_id: int, db: Session = Depends(get_db)):
    delete_teacher = teacher_crud.remove(teacher_id, db)
    if not delete_teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")
    return delete_teacher
