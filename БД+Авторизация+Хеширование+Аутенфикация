import os
from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from passlib.context import CryptContext
from jose import jwt, JWTError
from datetime import datetime, timedelta
from pydantic import BaseModel, Field
from typing import Optional, List, Generic, TypeVar, Type

from sqlalchemy.orm import Session, declarative_base, sessionmaker, relationship
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Table

SECRET_KEY = os.environ.get("SECRET_KEY", "my_secret_key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

DATABASE_URL = "sqlite:///database.db"
engine = create_engine(DATABASE_URL, connect_args={'check_same_thread': False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
app = FastAPI()

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/login")
ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
SimpleSchemaType = TypeVar("SimpleSchemaType", bound=BaseModel)
OutSchemaType = TypeVar("OutSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def password_hash(password):
    return pwd_context.hash(password)


def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> dict:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        raise HTTPException(status_code=401, detail="Token Error")


project_tag_table = Table(
    "project_tag",
    Base.metadata,
    Column("project_id", ForeignKey("projects.id"), primary_key=True),
    Column("tag_id", ForeignKey("tags.id"), primary_key=True)
)


# --- User table ---
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    username = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    role = Column(String, default="user")

    projects = relationship("Project", back_populates="owner")
    comments = relationship("Comment", back_populates="author")


# --- Project table ---
class Project(Base):
    __tablename__ = "projects"
    id = Column(Integer, primary_key=True)
    title = Column(String)
    description = Column(String, nullable=True)
    owner_id = Column(Integer, ForeignKey("users.id"))

    owner = relationship("User", back_populates="projects")
    comments = relationship("Comment", back_populates="project")
    tags = relationship("Tag", secondary=project_tag_table, back_populates="projects")


# --- Tag table ---
class Tag(Base):
    __tablename__ = "tags"
    id = Column(Integer, primary_key=True)
    name = Column(String, unique=True)

    projects = relationship("Project", secondary=project_tag_table, back_populates="tags")


# --- Comment table ---
class Comment(Base):
    __tablename__ = "comments"
    id = Column(Integer, primary_key=True)
    text = Column(String, nullable=True)
    project_id = Column(Integer, ForeignKey("projects.id"))
    user_id = Column(Integer, ForeignKey("users.id"))

    project = relationship("Project", back_populates="comments")
    author = relationship("User", back_populates="comments")


class CreateUser(BaseModel):
    username: str
    password: str


class Token(BaseModel):
    access_token: str
    token_type: str = 'Bearer'


class CreateProject(BaseModel):
    title: str
    description: Optional[str] = None


class CreateTag(BaseModel):
    name: str


class CreateComment(BaseModel):
    text: Optional[str] = None
    project_id: int


class UserSimpleOut(BaseModel):
    id: int
    username: str
    role: str

    class Config:
        orm_mode = True


class ProjectSimpleOut(BaseModel):
    id: int
    title: str
    description: Optional[str] = None

    class Config:
        orm_mode = True


class TagSimpleOut(BaseModel):
    id: int
    name: str

    class Config:
        orm_mode = True


class CommentSimpleOut(BaseModel):
    id: int
    text: Optional[str] = None


class CommentOut(BaseModel):
    id: int
    text: str

    class Config:
        orm_mode = True


class TagOut(BaseModel):
    id: int
    name: str
    projects: List[ProjectSimpleOut] = Field(default_factory=list)

    class Config:
        orm_mode = True


class ProjectOut(BaseModel):
    id: int
    title: str
    description: Optional[str] = None
    comments: List[CommentOut] = Field(default_factory=list)
    tags: List[TagSimpleOut] = Field(default_factory=list)

    class Config:
        orm_mode = True


class UserOut(BaseModel):
    id: int
    username: str
    role: str
    projects: List[ProjectSimpleOut] = Field(default_factory=list)
    comments: List[CommentOut] = Field(default_factory=list)

    class Config:
        orm_mode = True


class UpdateUser(BaseModel):
    username: Optional[str] = None
    password: Optional[str] = None

    class Config:
        orm_mode = True


class UpdateProject(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None

    class Config:
        orm_mode = True


class UpdateComment(BaseModel):
    text: Optional[str] = None

    class Config:
        orm_mode = True


class UpdateTag(BaseModel):
    name: Optional[str] = None

    class Config:
        orm_mode = True


class CRUDBase(Generic[ModelType, CreateSchemaType, SimpleSchemaType, OutSchemaType, UpdateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model

    def get_all(self, db: Session) -> List[ModelType]:
        return db.query(self.model).all()

    def get_one(self, db: Session, obj_id: int) -> ModelType:
        return db.query(self.model).filter(self.model.id == obj_id).first()

    def create(self, db: Session, obj_in: CreateSchemaType) -> ModelType:
        db_obj = self.model(**obj_in.dict(exclude_unset=True))
        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def update(self, db: Session, db_obj: ModelType, obj_in: UpdateSchemaType) -> ModelType:
        obj_data = obj_in.dict(exclude_unset=True)
        for field, value in obj_data.items():
            setattr(db_obj, field, value)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def remove(self, db: Session, obj_id: int):
        obj = db.query(self.model).filter(self.model.id == obj_id).first()
        if obj:
            db.delete(obj)
            db.commit()
            return obj


user_crud = CRUDBase(User)
project_crud = CRUDBase(Project)
tag_crud = CRUDBase(Tag)
comment_crud = CRUDBase(Comment)

Base.metadata.create_all(bind=engine)


def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    payload = decode_token(token)
    username = payload.get("sub")
    if not username:
        raise HTTPException(status_code=401, detail="Token Error")
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user


def require_admin(current_user: User = Depends(get_current_user)):
    if current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="Forbidden")
    return current_user


@app.post('/register', response_model=UserOut)
def register(user: CreateUser, db: Session = Depends(get_db)):
    if db.query(User).filter(User.username == user.username).first():
        raise HTTPException(status_code=400, detail="Username already exists")
    hashed_password = password_hash(user.password)
    new_user = User(username=user.username, hashed_password=hashed_password, role='user')
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user


@app.post('/login', response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = db.query(User).filter(User.username == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(status_code=400, detail="Incorrect password")
    access_token = create_access_token(data={"sub": user.username, "role": user.role})
    return {"access_token": access_token, "token_type": "Bearer"}


@app.get('/me', response_model=UserOut)
def me(current_user: User = Depends(get_current_user)):
    return current_user


@app.post('/projects', response_model=ProjectOut)
def projects(project: CreateProject, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    if db.query(Project).filter(Project.title == project.title).first():
        raise HTTPException(status_code=400, detail="Project already exists")
    new_project = Project(title=project.title, description=project.description, owner_id=current_user.id)
    db.add(new_project)
    db.commit()
    db.refresh(new_project)
    return new_project


@app.get('/projects', response_model=List[ProjectOut])
def projects(db: Session = Depends(get_db)):
    return db.query(Project).all()


@app.get('/projects/{project_id}', response_model=ProjectOut)
def read_projects(project_id: int, db: Session = Depends(get_db)):
    get_project = project_crud.get_one(db, project_id)
    if not get_project:
        raise HTTPException(status_code=404, detail="Project not found")
    return get_project


@app.put('/projects/{project_id}', response_model=ProjectOut)
def update_projects(project_id: int, project_update: UpdateProject, db: Session = Depends(get_db),
                    current_user: User = Depends(get_current_user)):
    put_project = db.query(Project).filter(Project.id == project_id).first()
    if not put_project:
        raise HTTPException(status_code=404, detail="Project not found")
    if put_project.owner_id != current_user.id and current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="Forbidden")
    return project_crud.update(db, put_project, project_update)


@app.delete('/projects/{project_id}', response_model=ProjectOut)
def delete_projects(project_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    delete_project = db.query(Project).filter(Project.id == project_id).first()
    if not delete_project:
        raise HTTPException(status_code=404, detail="Project not found")
    if delete_project.owner_id != current_user.id and current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="Forbidden")
    db.delete(delete_project)
    db.commit()
    return delete_project


@app.post('/tags', response_model=TagOut)
def tags(tag: CreateTag, db: Session = Depends(get_db), _: User = Depends(require_admin)):
    if db.query(Tag).filter(Tag.name == tag.name).first():
        raise HTTPException(status_code=400, detail="Tag already exists")
    new_tag = Tag(name=tag.name)
    db.add(new_tag)
    db.commit()
    db.refresh(new_tag)
    return new_tag


@app.get('/tags', response_model=List[TagOut])
def tags(db: Session = Depends(get_db)):
    return db.query(Tag).all()


@app.post('/projects/{project_id}/tags/{tag_id}', response_model=TagOut)
def add_tag_to_project(project_id: int, tag_id: int, db: Session = Depends(get_db),
                       current_user: User = Depends(get_current_user)):
    project = db.query(Project).filter(Project.id == project_id).first()
    tag = db.query(Tag).filter(Tag.id == tag_id).first()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    if not tag:
        raise HTTPException(status_code=404, detail="Tag not found")
    if tag in project.tags:
        raise HTTPException(status_code=400, detail="Tag already exists")
    project.tags.append(tag)
    db.commit()
    db.refresh(tag)
    return tag


@app.delete('/projects/{project_id}/tags/{tag_id}', response_model=TagOut)
def delete_tag_from_projects(project_id: int, tag_id: int, db: Session = Depends(get_db),
                             current_user: User = Depends(get_current_user)):
    project = db.query(Project).filter(Project.id == project_id).first()
    tag = db.query(Tag).filter(Tag.id == tag_id).first()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    if not tag:
        raise HTTPException(status_code=404, detail="Tag not found")
    if tag not in project.tags:
        raise HTTPException(status_code=403, detail="Forbidden")
    project.tags.remove(tag)
    db.commit()
    db.refresh(tag)
    return tag


@app.post('/comments', response_model=CommentOut)
def create_comments(comment: CreateComment, db: Session = Depends(get_db),
                    current_user: User = Depends(get_current_user)):
    project = db.query(Project).filter(Project.id == comment.project_id).first()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    if db.query(Comment).filter(Comment.text == comment.text, Comment.project_id == comment.project_id).first():
        raise HTTPException(status_code=400, detail="Comment already exists")
    new_comment = Comment(text=comment.text, project_id=comment.project_id, user_id=current_user.id)
    db.add(new_comment)
    db.commit()
    db.refresh(new_comment)
    return new_comment
