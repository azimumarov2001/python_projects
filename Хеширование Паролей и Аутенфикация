from __future__ import annotations
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from sqlalchemy.orm import Session, declarative_base, sessionmaker, relationship
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey
from typing import Optional, List
from passlib.context import CryptContext

DATABASE_URL = "sqlite:///test.db"
engine = create_engine(DATABASE_URL, connect_args={'check_same_thread': False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
app = FastAPI()

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def password_hash(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, nullable=False)
    hashed_password = Column(String, nullable=False)

    # Связь с домашними заданиями (один ко многим)
    homeworks = relationship("Homework", back_populates="student")


class Teacher(Base):
    __tablename__ = "teachers"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, nullable=False)
    hashed_password = Column(String, nullable=False)

    # Связь с домашними заданиями (один ко многим)
    homeworks = relationship("Homework", back_populates="teacher")


class Homework(Base):
    __tablename__ = "homeworks"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(String, nullable=True)

    student_id = Column(Integer, ForeignKey("users.id"))
    teacher_id = Column(Integer, ForeignKey("teachers.id"))

    student = relationship("User", back_populates="homeworks")
    teacher = relationship("Teacher", back_populates="homeworks")


class CreateUser(BaseModel):
    username: str
    password: str


class LoginUser(BaseModel):
    username: str
    password: str


class CreateTeacher(BaseModel):
    username: str
    password: str


class LoginTeacher(BaseModel):
    username: str
    password: str


class CreateHomework(BaseModel):
    title: str
    description: str
    student_id: int
    teacher_id: int


class HomeworkOut(BaseModel):
    id: int
    title: str
    description: Optional[str] = None
    student_id: int
    teacher_id: int

    class Config:
        orm_mode = True


class UserOut(BaseModel):
    id: int
    username: str
    homeworks: List[HomeworkOut] = []

    class Config:
        orm_mode = True


class TeacherOut(BaseModel):
    id: int
    username: str
    homeworks: List[HomeworkOut] = []

    class Config:
        orm_mode = True


class UpdateUser(BaseModel):
    username: Optional[str] = None
    password: Optional[str] = None

    class Config:
        orm_mode = True


class UpdateTeacher(BaseModel):
    username: Optional[str] = None
    password: Optional[str] = None

    class Config:
        orm_mode = True


class UpdateHomework(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    student_id: Optional[int] = None
    teacher_id: Optional[int] = None

    class Config:
        orm_mode = True


Base.metadata.create_all(bind=engine)


@app.post("/users/register", response_model=UserOut)
def register_user(user: CreateUser, db: Session = Depends(get_db)):
    if db.query(User).filter(User.username == user.username).first():
        raise HTTPException(status_code=400, detail='Username already exists')
    new_user = User(username=user.username, hashed_password=password_hash(user.password))
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user


@app.post("/users/login", response_model=UserOut)
def login_user(user: LoginUser, db: Session = Depends(get_db)):
    check_user = db.query(User).filter(User.username == user.username).first()
    if not check_user or not verify_password(user.password, check_user.hashed_password):
        raise HTTPException(status_code=401, detail='Incorrect username or password')
    return check_user


@app.get("/users", response_model=List[UserOut])
def read_users(db: Session = Depends(get_db)):
    return db.query(User).all()


@app.get("/users/{user_id}", response_model=UserOut)
def read_user(user_id: int, db: Session = Depends(get_db)):
    get_user = db.query(User).filter(User.id == user_id).first()
    if not get_user:
        raise HTTPException(status_code=404, detail='User not found')
    return get_user


@app.put("/users/{user_id}", response_model=UserOut)
def update_user(user_id: int, user_update: UpdateUser, db: Session = Depends(get_db)):
    put_user = db.query(User).filter(User.id == user_id).first()
    if not put_user:
        raise HTTPException(status_code=404, detail='User not found')
    if user_update.username is not None:
        put_user.username = user_update.username
    if user_update.password is not None:
        put_user.hashed_password = password_hash(user_update.password)
    db.commit()
    db.refresh(put_user)
    return put_user


@app.delete("/users/{user_id}")
def delete_users(user_id: int, db: Session = Depends(get_db)):
    delete_user = db.query(User).filter(User.id == user_id).first()
    if not delete_user:
        raise HTTPException(status_code=404, detail='User not found')
    db.delete(delete_user)
    db.commit()
    return {'message': 'User deleted'}


@app.post("/homeworks", response_model=HomeworkOut)
def create_homework(homework: CreateHomework, db: Session = Depends(get_db)):
    check_user = db.query(User).filter(User.id == homework.student_id).first()
    if not check_user:
        raise HTTPException(status_code=404, detail='User not found')
    check_teacher = db.query(Teacher).filter(Teacher.id == homework.teacher_id).first()
    if not check_teacher:
        raise HTTPException(status_code=404, detail='Teacher not found')
    new_homework = Homework(title=homework.title, description=homework.description, student_id=homework.student_id,
                            teacher_id=homework.teacher_id)
    db.add(new_homework)
    db.commit()
    db.refresh(new_homework)
    return new_homework


@app.get("/homeworks", response_model=List[HomeworkOut])
def read_homeworks(db: Session = Depends(get_db)):
    return db.query(Homework).all()


@app.get("/homeworks/{homework_id}", response_model=HomeworkOut)
def read_homework(homework_id: int, db: Session = Depends(get_db)):
    get_homework = db.query(Homework).filter(Homework.id == homework_id).first()
    if not get_homework:
        raise HTTPException(status_code=404, detail='Homework not found')
    return get_homework


@app.put("/homeworks/{homework_id}", response_model=HomeworkOut)
def update_homework(homework_id: int, homework_update: UpdateHomework, db: Session = Depends(get_db)):
    put_homework = db.query(Homework).filter(Homework.id == homework_id).first()
    if not put_homework:
        raise HTTPException(status_code=404, detail='Homework not found')
    if homework_update.title is not None:
        put_homework.title = homework_update.title
    if homework_update.description is not None:
        put_homework.description = homework_update.description
    if homework_update.student_id is not None:
        put_homework.student_id = homework_update.student_id
    if homework_update.teacher_id is not None:
        put_homework.teacher_id = homework_update.teacher_id
    db.commit()
    db.refresh(put_homework)
    return put_homework


@app.delete("/homeworks/{homework_id}")
def delete_homeworks(homework_id: int, db: Session = Depends(get_db)):
    delete_homework = db.query(Homework).filter(Homework.id == homework_id).first()
    if not delete_homework:
        raise HTTPException(status_code=404, detail='Homework not found')
    db.delete(delete_homework)
    db.commit()
    return {'message': 'Homework deleted'}
